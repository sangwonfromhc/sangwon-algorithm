import java.io.*;
import java.util.Stack;
import java.util.Arrays;

public class Main {  
    public static String keylog(String pw){ //pw = 입력 (T 아님.)
    Stack<Character> lStack = new Stack<Character>();
    Stack<Character> rStack = new Stack<Character>(); // 커서 기준 좌, 우 스택 생성.

    char s;

    for(int i=0;i<pw.length();i++){
        s = pw.charAt(i);
        if(s == '<'){
            if(!lStack.empty())    // 좌스택이 없다 = 커서가 이미 맨 왼쪽. 
                rStack.push(lStack.pop()); // 좌스택에서 우스택으로 옮김. ex) abc| => ab|c .. 커서 기준으로 스택. 좌스택에서 빼서 우스택으로 이동.
            }
        else if(s == '>'){
                if(!rStack.empty())    
                    lStack.push(rStack.pop());
            }
        else if(s == '-'){
                if(!lStack.empty())
                    lStack.pop(); // 커서기준 오른쪽 지움이니, 좌스택에서 요소 하나 빼기
            }
        else
                lStack.push(pw.charAt(i)); // 그 외는 새로운 입력이므로, 추가. 
        }
        //좌스택이 빌 때 까지 우스택으로 이동. ABCD가 최종 문자열이라면, 우스택은 ABCD 로 쌓일 것이고, 나중에 char temp배열로 pop할 때 순서대로 추가되는 식(first in Last out)      
        while(!lStack.empty()) 
            rStack.push(lStack.pop()); 
        
        int i=0;
        char[] temp = new char[rStack.size()]; // char형 temp배열 생성, 사이즈 미리 정해줬다. tmi. 사지방이라 웹 컴파일러로하는 중, 자꾸 초기화 안했다고 난리쳐서 사이즈를 정해줬다. 
        
        while(!rStack.empty()){ 
            temp[i] = rStack.pop();
            i++;
        }
        //String.valueOf(배열) = 배열을 문자열로 반환하는 메서드다. 비슷한 걸로, Array.toString이 있다. 차이는 구글링하면 쉽게나온다.
        return String.valueOf(temp);
        

 }
     public static void main(String[] args) throws IOException { 

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 

        int T = Integer.parseInt(br.readLine());
        String pw;
        String output[] = new String[T];
        
        for(int i = 0;i<T;i++){
            pw = br.readLine();
            output[i] = keylog(pw);       
        }
        
        for(int i = 0;i<T;i++)   
            System.out.printf(output[i]+"\n");  
                  
   } 

}
