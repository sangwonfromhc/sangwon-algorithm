커서 기준으로 lStack(왼쪽) , rStack(오른쪽)으로 스택 두개를 만든다.
기본적으로 커서는 다 입력 받은 후 맨 오른쪽에 있다. ex) a b c | <-커서
그렇기에, lStack 먼저 charAt 메소드를 이용해 채워준다. ( BufferredReader는 String type으로 받기에, char형으로 바꿔 입력해주는 charAt메소드 이용)
커서 왼쪽 이동 => 커서가 맨 왼쪽에 있지 않아야 한다. 즉, lStack이 비어있지 않으면 = !lStack.empty()
              => rStack.push(lStack.pop()); rStack 에 lStack 맨 위에 것을 추가. 즉 커서 이동. 나중가면 lStack, rStack 합치기에, 스택내 요소 이동을 커서 이동으로 표현 한 것.
              cf. Stack.pop()은 통상적으로 제거한다라는 의미를 가졌지만. pop메소드 소스코드를 보면, 맨 위 값을 반환한다.

중요한 점은. 백준 알고리즘에는 연결리스트 문제로 분류되어있다. 
하지만 연결리스트 소스코드를 보면 알겠지만, 삽입/삭제에, haed,tail을 제외한 모든 요소를 탐색하는, 즉 입력하는 양과 탐색하는시간(작업시간)이 비례하는 O(n)의 시간 복잡도를 가진다. 
Stack은 시간복잡도가 O(1)이다. 당장 1406문제만 봐도, 입력하는 양이 어떻든, 실행되는 작업(= 작업시간)은 일정하다. 
연결리스트로도 충분히 구현 가능하고, 부스트코스 자바 자료구조 강의를 봤기에 구현하는 방법은 쉽다. 문제 해결 원리라 할 것도 없이. 
